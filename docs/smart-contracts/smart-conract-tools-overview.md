# Smart Contract Tools overview

This article introduces tools designed to help developers working with smart contracts on the blockchain. These tools
offer a range of capabilities, from testing smart contracts to facilitating command-line interactions with the
blockchain, and even integrating the blockchain with your own applications.

## The browser

The browser serves as a web-based interface to translate blockchain data into a user-friendly application. It aids
developers in creating smart contracts by providing insights into transaction details and contract deployment status.
You can access two versions of the browser:

The browser has two versions:

- [TestNet version](https://browser.testnet.partisiablockchain.com)
- [MainNet version](https://browser.partisiablockchain.com)

## Partisia contract extensions

The Partisia contract is used to build and compile smart contracts. It offers several extensions to assist you in
interacting with the blockchain and working with smart contracts. These extensions are thoroughly documented as part of
the tool, enabling you to explore their capabilities inside `cargo partisia-contract`. Here is a brief overview of the
primary extensions:

### `cargo partisia-contract abi`

This extension is focused on helping you understand the [ABI](../pbc-fundamentals/dictionary.md#abi) actions of a
contract, providing insight into its input requirements. By using the command `cargo partisa-contract abi show`, you can
access information about a compiled contract's state, initialization, actions, and variables. It simplifies the process
of identifying shortnames for existing contracts using optional arguments. This extension is using
the [abi-client](#abi-client).

Example
command: `cargo partisia-contract abi show example-contracts/target/wasm32-unknown-unknown/release/auction_contract.abi`

??? example "Response from example command"
```
pub struct Bid {
bidder: Address,
amount: u128,
}
pub struct SecretVarId {
raw_id: u32,
}
pub struct TokenClaim {
tokens_for_bidding: u128,
tokens_for_sale: u128,
}
#[state]
pub struct AuctionContractState {
contract_owner: Address,
start_time_millis: i64,
end_time_millis: i64,
token_amount_for_sale: u128,
token_for_sale: Address,
token_for_bidding: Address,
highest_bidder: Bid,
reserve_price: u128,
min_increment: u128,
claim_map: Map<Address, TokenClaim>,
status: u8,
}
#[init]
pub fn initialize (
token_amount_for_sale: u128,
token_for_sale: Address,
token_for_bidding: Address,
reserve_price: u128,
min_increment: u128,
auction_duration_hours: u32,
)
#[action(shortname = 0x01)]
pub fn start ()
#[action(shortname = 0x03)]
pub fn bid (
bid_amount: u128,
)
#[action(shortname = 0x05)]
pub fn claim ()
#[action(shortname = 0x06)]
pub fn execute ()
#[action(shortname = 0x07)]
pub fn cancel ()
#[callback(shortname = 0x02)]
pub fn start_callback ()
#[callback(shortname = 0x04)]
pub fn bid_callback (
bid: Bid,
)
```

### `cargo partisia-contract abi codegen`

Codegen offers autogenerated code in both Java & TypeScript to streamline interactions with contract actions. The
autogenerated code provides methods to
interact with actions based on a smart contracts [abi](../pbc-fundamentals/dictionary.md#abi). We recommend you
follow [the readme here](https://gitlab.com/secata/pbc/language/abi/abi-client/-/tree/main/maven-plugin?ref_type=heads)
to automate your usage of abi codegen.

Abi codegen can also be used manually. Here is an example of how:
`cargo partisia-contract abi codegen --java mySmartContract/target/wasm32-unknown-unknown/release/auction_contract.abi mySmartContract/AutogeneratedCode/auction_contract.java`

??? example "Response from example command"

    ```java
    // This file is auto-generated from an abi-file using abi-client's AbiCodeGen.
    package com.partisiablockchain.language.abicodegen;
    
    import com.partisiablockchain.BlockchainAddress;
    import com.partisiablockchain.crypto.BlockchainPublicKey;
    import com.partisiablockchain.crypto.BlsPublicKey;
    import com.partisiablockchain.crypto.BlsSignature;
    import com.partisiablockchain.crypto.Hash;
    import com.partisiablockchain.crypto.Signature;
    import com.partisiablockchain.language.abiclient.BigEndianReader;
    import com.partisiablockchain.language.abiclient.builder.AbstractBuilder;
    import com.partisiablockchain.language.abiclient.builder.StructProducer;
    import com.partisiablockchain.language.abiclient.parser.AbiParser;
    import com.partisiablockchain.language.abiclient.parser.FnKind;
    import com.partisiablockchain.language.abiclient.rpc.FnRpcBuilder;
    import com.partisiablockchain.language.abiclient.rpc.RpcReader;
    import com.partisiablockchain.language.abiclient.state.StateReader;
    import com.partisiablockchain.language.abiclient.types.FileAbi;
    import com.partisiablockchain.language.abiclient.types.NamedTypeRef;
    import com.partisiablockchain.language.abiclient.value.ScValue;
    import com.partisiablockchain.language.abiclient.value.ScValueOption;
    import com.partisiablockchain.language.abiclient.value.ScValueStruct;
    import com.partisiablockchain.language.abiclient.value.ScValueEnum;
    import com.partisiablockchain.language.abicodegen.AbiGenerated;
    import com.secata.stream.BigEndianByteOutput;
    import com.secata.stream.SafeDataInputStream;
    import com.secata.stream.SafeDataOutputStream;
    import java.math.BigInteger;
    import java.util.HexFormat;
    import java.util.List;
    import java.util.Map;
    import java.util.stream.Collectors;
    
    @AbiGenerated
    public final class auction_contract {
    
      static FileAbi fileAbi = new AbiParser(HexFormat.of().parseHex(
                "50424341424909040005020000000004010000000342696400000002000000066269646465720d00000006616d6f756e7405010000000a546f6b656e436c61696d0000000200000012746f6b656e735f666f725f62696464696e67050000000f746f6b656e735f666f725f73616c6505010000001441756374696f6e436f6e747261637453746174650000000b0000000e636f6e74726163745f6f776e65720d0000001173746172745f74696d655f6d696c6c6973090000000f656e645f74696d655f6d696c6c69730900000015746f6b656e5f616d6f756e745f666f725f73616c65050000000e746f6b656e5f666f725f73616c650d00000011746f6b656e5f666f725f62696464696e670d0000000e686967686573745f62696464657200000000000d726573657276655f7072696365050000000d6d696e5f696e6372656d656e740500000009636c61696d5f6d61700f0d00010000000673746174757301010000000b536563726574566172496400000001000000067261775f69640300000008010000000a696e697469616c697a65ffffffff0f0000000600000015746f6b656e5f616d6f756e745f666f725f73616c65050000000e746f6b656e5f666f725f73616c650d00000011746f6b656e5f666f725f62696464696e670d0000000d726573657276655f7072696365050000000d6d696e5f696e6372656d656e74050000001661756374696f6e5f6475726174696f6e5f686f75727303020000000573746172740100000000030000000e73746172745f63616c6c6261636b0200000000020000000362696403000000010000000a6269645f616d6f756e7405030000000c6269645f63616c6c6261636b04000000010000000362696400000200000005636c61696d05000000000200000007657865637574650600000000020000000663616e63656c07000000000002"
              )).parseAbi();
    
      @AbiGenerated
      public record Bid(BlockchainAddress bidder, BigInteger amount) {
        public void buildRpc(AbstractBuilder builder) {
          var structBuilder = builder.addStruct();
          structBuilder.addAddress(SafeDataOutputStream.serialize(bidder::write));
          structBuilder.addU128(amount);
        }
    
        private static Bid fromScValue(ScValueStruct structValue) {
          return new Bid(
            BlockchainAddress.read(SafeDataInputStream.createFromBytes(structValue.getFieldValue("bidder").addressValue().bytes())),
            structValue.getFieldValue("amount").u128Value()
          );
        }
    
      }
    
      @AbiGenerated
      public record TokenClaim(BigInteger tokensForBidding, BigInteger tokensForSale) {
        private static TokenClaim fromScValue(ScValueStruct structValue) {
          return new TokenClaim(
            structValue.getFieldValue("tokens_for_bidding").u128Value(),
            structValue.getFieldValue("tokens_for_sale").u128Value()
          );
        }
    
      }
    
      @AbiGenerated
      public record AuctionContractState(BlockchainAddress contractOwner, long startTimeMillis, long endTimeMillis, BigInteger tokenAmountForSale, BlockchainAddress tokenForSale, BlockchainAddress tokenForBidding, Bid highestBidder, BigInteger reservePrice, BigInteger minIncrement, Map<BlockchainAddress, TokenClaim> claimMap, byte status) {
        private static AuctionContractState fromScValue(ScValueStruct structValue) {
          return new AuctionContractState(
            BlockchainAddress.read(SafeDataInputStream.createFromBytes(structValue.getFieldValue("contract_owner").addressValue().bytes())),
            structValue.getFieldValue("start_time_millis").i64Value(),
            structValue.getFieldValue("end_time_millis").i64Value(),
            structValue.getFieldValue("token_amount_for_sale").u128Value(),
            BlockchainAddress.read(SafeDataInputStream.createFromBytes(structValue.getFieldValue("token_for_sale").addressValue().bytes())),
            BlockchainAddress.read(SafeDataInputStream.createFromBytes(structValue.getFieldValue("token_for_bidding").addressValue().bytes())),
            Bid.fromScValue(structValue.getFieldValue("highest_bidder").structValue()),
            structValue.getFieldValue("reserve_price").u128Value(),
            structValue.getFieldValue("min_increment").u128Value(),
            structValue.getFieldValue("claim_map").mapValue().map().entrySet().stream().collect(Collectors.toMap(k1 -> BlockchainAddress.read(SafeDataInputStream.createFromBytes(k1.getKey().addressValue().bytes())), v2 -> TokenClaim.fromScValue(v2.getValue().structValue()))),
            structValue.getFieldValue("status").u8Value()
          );
        }
    
        public static AuctionContractState deserialize(byte[] bytes) {
          var structValue = new StateReader(bytes, fileAbi.contract()).readState();
          return AuctionContractState.fromScValue(structValue);
        }
    
      }
    
      @AbiGenerated
      public record SecretVarId(int rawId) {
        private static SecretVarId fromScValue(ScValueStruct structValue) {
          return new SecretVarId(
            structValue.getFieldValue("raw_id").u32Value()
          );
        }
    
      }
    
      public static byte[] initialize(BigInteger tokenAmountForSale, BlockchainAddress tokenForSale, BlockchainAddress tokenForBidding, BigInteger reservePrice, BigInteger minIncrement, int auctionDurationHours) {
        FnRpcBuilder fnBuilder = new FnRpcBuilder("initialize", fileAbi.contract());
        fnBuilder.addU128(tokenAmountForSale);
        fnBuilder.addAddress(SafeDataOutputStream.serialize(tokenForSale::write));
        fnBuilder.addAddress(SafeDataOutputStream.serialize(tokenForBidding::write));
        fnBuilder.addU128(reservePrice);
        fnBuilder.addU128(minIncrement);
        fnBuilder.addU32(auctionDurationHours);
        return fnBuilder.getBytes();
      }
    
      public static byte[] start() {
        FnRpcBuilder fnBuilder = new FnRpcBuilder("start", fileAbi.contract());
        return fnBuilder.getBytes();
      }
    
      public static byte[] bid(BigInteger bidAmount) {
        FnRpcBuilder fnBuilder = new FnRpcBuilder("bid", fileAbi.contract());
        fnBuilder.addU128(bidAmount);
        return fnBuilder.getBytes();
      }
    
      public static byte[] claim() {
        FnRpcBuilder fnBuilder = new FnRpcBuilder("claim", fileAbi.contract());
        return fnBuilder.getBytes();
      }
    
      public static byte[] execute() {
        FnRpcBuilder fnBuilder = new FnRpcBuilder("execute", fileAbi.contract());
        return fnBuilder.getBytes();
      }
    
      public static byte[] cancel() {
        FnRpcBuilder fnBuilder = new FnRpcBuilder("cancel", fileAbi.contract());
        return fnBuilder.getBytes();
      }
    
    }
    ```

### `cargo partisia-contract cli`

cli is a command-line interface for you to interact with the blockchain.

To start using the CLI you can try minting some test_coin with the following command:
`cargo partisia-contract cli tx action 02c14c29b2697f3c983ada0ee7fac83f8a937e2ecd feed_me [PublicAddressYouWantMintToGoTo] --gas 60000 --privatekey=PathToPrivatekeyFile`

If you need the above specification for the tx you can type: `cargo partisia-contract cli tx action`

Want to explore more possibilities? You can go visit the [cli-execution-reference-tests to see example usage
of the CLI tool](https://gitlab.com/partisiablockchain/language/partisia-cli/-/tree/main/src/test/resources/cli-execution-reference-tests?ref_type=heads)
You can look in the commandline.sh that is placed within each test folder to understand the multitude of applications
this tool can have.

## abi-client

Our Smart Contract Binary Interface Client Library allows you to interact with the blockchain programmatically. It
offers a standard binary interface for deploying contracts and creating transactions, making it ideal to use serverside
for signing transactions.

ABI-Client has two versions:

- [Java version](https://gitlab.com/partisiablockchain/language/abi/abi-client/-/tree/main?ref_type=heads)
- [TypeScript version](https://gitlab.com/partisiablockchain/language/abi/abi-client-ts)

When using the abi-client we generally recommend using codegen when possible for a more straightforward and
plug-and-play interaction with the blockchain. Abi-client can be used to read from contracts that is not necessarily
linked to a specific contract on the blockchain.

We have created an [example client](#example-client) to showcase how to work with the abi-client.

## zk-client

Enables the generation
of [rpc](https://partisiablockchain.gitlab.io/documentation/smart-contracts/smart-contract-binary-formats.html#rpc-binary-format)
for ZK inputs. The zk-client is here to
help you interact with the blockchain through code integrations. You can visit the tests inside the projects to see how
it works and start from there.

There are two versions of the zk-client:

- [Java version](https://gitlab.com/partisiablockchain/language/abi/zk-client/)
- [TypeScript version](https://gitlab.com/partisiablockchain/language/abi/zk-client-ts)

## Example client

This is a front end and a backend example of how to integrate you application with Partisia Blockchain, specifically it
uses the [abi-client](#abi-client) to send transactions and read states of the contracts.

The example client comes in two versions:

- [Java version](https://gitlab.com/secata/pbc/language/example-client)
- [TypeScript version](https://gitlab.com/secata/pbc/language/example-web-client)
