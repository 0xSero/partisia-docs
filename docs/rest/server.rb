#
# 
#
# Generated by <a href="http://enunciate.webcohesion.com">Enunciate</a>.
#
require 'json'

# adding necessary json serialization methods to standard classes.
class Object
  def to_jaxb_json_hash
    return self
  end
  def self.from_json o
    return o
  end
end

class String
  def self.from_json o
    return o
  end
end

class Boolean
  def self.from_json o
    return o
  end
end

class Numeric
  def self.from_json o
    return o
  end
end

class Time
  #json time is represented as number of milliseconds since epoch
  def to_jaxb_json_hash
    return (to_i * 1000) + (usec / 1000)
  end
  def self.from_json o
    if o.nil?
      return nil
    else
      return Time.at(o / 1000, (o % 1000) * 1000)
    end
  end
end

class Array
  def to_jaxb_json_hash
    a = Array.new
    each { | _item | a.push _item.to_jaxb_json_hash }
    return a
  end
end

class Hash
  def to_jaxb_json_hash
    h = Hash.new
    each { | _key, _value | h[_key.to_jaxb_json_hash] = _value.to_jaxb_json_hash }
    return h
  end
end

module EnunciateHelpers
  LAMB_CLASS_AWARE = ->(_item) do
    java_clazz = _item['@class']
    clazz_array_parts = java_clazz.split('.')
    short_clazz = clazz_array_parts.pop
    clazz_package = clazz_array_parts.map do |e| e[0] = e.first.capitalize; e end.join("::")
    clazz = clazz_package + "::" + short_clazz
    Object.const_get(clazz).send(:from_json, _item)
  end
end


module Io

module Privacyblockchain

module Rest

module Dto

  # (no documentation provided)
  class JarDto 

    # (no documentation provided)
    attr_accessor :jar

    # the json hash for this JarDto
    def to_jaxb_json_hash
      _h = {}
      if !jar.nil?
        _ha = Array.new
        jar.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['jar'] = _ha
      end
      return _h
    end

    # the json (string form) for this JarDto
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this JarDto with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['jar'].nil?
          _oa = _o['jar']
            if(_oa.is_a? Hash)
              @jar = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @jar =  Fixnum.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @jar = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @jar.push Fixnum.from_json(_item)
                 else
                   @jar.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @jar = _oa
            end
          end
    end

    # constructs a JarDto from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

module Io

module Privacyblockchain

module Rest

module Dto

  # (no documentation provided)
  class FeatureDto 

    # (no documentation provided)
    attr_accessor :value

    # the json hash for this FeatureDto
    def to_jaxb_json_hash
      _h = {}
      _h['value'] = value.to_jaxb_json_hash unless value.nil?
      return _h
    end

    # the json (string form) for this FeatureDto
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this FeatureDto with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['value'].nil?
          _oa = _o['value']
            if(_oa.is_a? Hash)
              @value = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @value =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @value = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @value.push String.from_json(_item)
                 else
                   @value.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @value = _oa
            end
          end
    end

    # constructs a FeatureDto from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

module Io

module Privacyblockchain

module Rest

module Dto

  # (no documentation provided)
  class ContractStateDto 

    # (no documentation provided)
    attr_accessor :address
    # (no documentation provided)
    attr_accessor :owner
    # (no documentation provided)
    attr_accessor :serializedContract
    # (no documentation provided)
    attr_accessor :jarHash
    # (no documentation provided)
    attr_accessor :type
    # (no documentation provided)
    attr_accessor :storageLength

    # the json hash for this ContractStateDto
    def to_jaxb_json_hash
      _h = {}
      _h['address'] = address.to_jaxb_json_hash unless address.nil?
      _h['owner'] = owner.to_jaxb_json_hash unless owner.nil?
      _h['serializedContract'] = serializedContract.to_jaxb_json_hash unless serializedContract.nil?
      _h['jarHash'] = jarHash.to_jaxb_json_hash unless jarHash.nil?
      _h['type'] = type.to_jaxb_json_hash unless type.nil?
      _h['storageLength'] = storageLength.to_jaxb_json_hash unless storageLength.nil?
      return _h
    end

    # the json (string form) for this ContractStateDto
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this ContractStateDto with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['address'].nil?
          _oa = _o['address']
            if(_oa.is_a? Hash)
              @address = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @address =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @address = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @address.push String.from_json(_item)
                 else
                   @address.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @address = _oa
            end
          end
        if !_o['owner'].nil?
          _oa = _o['owner']
            if(_oa.is_a? Hash)
              @owner = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @owner =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @owner = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @owner.push String.from_json(_item)
                 else
                   @owner.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @owner = _oa
            end
          end
        if !_o['serializedContract'].nil?
          _oa = _o['serializedContract']
            if(_oa.is_a? Hash)
              @serializedContract = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @serializedContract =  com.fasterxml.jackson.databind::JsonNode.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @serializedContract = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @serializedContract.push com.fasterxml.jackson.databind::JsonNode.from_json(_item)
                 else
                   @serializedContract.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @serializedContract = _oa
            end
          end
        if !_o['jarHash'].nil?
          _oa = _o['jarHash']
            if(_oa.is_a? Hash)
              @jarHash = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @jarHash =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @jarHash = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @jarHash.push String.from_json(_item)
                 else
                   @jarHash.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @jarHash = _oa
            end
          end
        if !_o['type'].nil?
          _oa = _o['type']
            if(_oa.is_a? Hash)
              @type = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @type =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @type = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @type.push String.from_json(_item)
                 else
                   @type.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @type = _oa
            end
          end
        if !_o['storageLength'].nil?
          _oa = _o['storageLength']
            if(_oa.is_a? Hash)
              @storageLength = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @storageLength =  Bignum.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @storageLength = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @storageLength.push Bignum.from_json(_item)
                 else
                   @storageLength.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @storageLength = _oa
            end
          end
    end

    # constructs a ContractStateDto from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

module Io

module Privacyblockchain

module Rest

module Dto

  # (no documentation provided)
  class IncomingTransactionDto 

    # (no documentation provided)
    attr_accessor :transactionPayload

    # the json hash for this IncomingTransactionDto
    def to_jaxb_json_hash
      _h = {}
      if !transactionPayload.nil?
        _ha = Array.new
        transactionPayload.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['transactionPayload'] = _ha
      end
      return _h
    end

    # the json (string form) for this IncomingTransactionDto
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this IncomingTransactionDto with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['transactionPayload'].nil?
          _oa = _o['transactionPayload']
            if(_oa.is_a? Hash)
              @transactionPayload = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @transactionPayload =  Fixnum.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @transactionPayload = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @transactionPayload.push Fixnum.from_json(_item)
                 else
                   @transactionPayload.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @transactionPayload = _oa
            end
          end
    end

    # constructs a IncomingTransactionDto from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

module Io

module Privacyblockchain

module Rest

module Dto

  # (no documentation provided)
  class EventDto 

    # (no documentation provided)
    attr_accessor :destinationShard
    # (no documentation provided)
    attr_accessor :identifier

    # the json hash for this EventDto
    def to_jaxb_json_hash
      _h = {}
      _h['destinationShard'] = destinationShard.to_jaxb_json_hash unless destinationShard.nil?
      _h['identifier'] = identifier.to_jaxb_json_hash unless identifier.nil?
      return _h
    end

    # the json (string form) for this EventDto
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this EventDto with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['destinationShard'].nil?
          _oa = _o['destinationShard']
            if(_oa.is_a? Hash)
              @destinationShard = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @destinationShard =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @destinationShard = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @destinationShard.push String.from_json(_item)
                 else
                   @destinationShard.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @destinationShard = _oa
            end
          end
        if !_o['identifier'].nil?
          _oa = _o['identifier']
            if(_oa.is_a? Hash)
              @identifier = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @identifier =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @identifier = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @identifier.push String.from_json(_item)
                 else
                   @identifier.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @identifier = _oa
            end
          end
    end

    # constructs a EventDto from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

module Io

module Privacyblockchain

module Rest

module Dto

module Traversing

  # (no documentation provided)
  class TraverseDto 


    # the json hash for this TraverseDto
    def to_jaxb_json_hash
      _h = {}
      return _h
    end

    # the json (string form) for this TraverseDto
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this TraverseDto with a json hash
    def init_jaxb_json_hash(_o)
    end

    # constructs a TraverseDto from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

module Io

module Privacyblockchain

module Rest

module Dto

module Traversing

  # (no documentation provided)
  class AvlTraverseDto 

    # (no documentation provided)
    attr_accessor :keyType
    # (no documentation provided)
    attr_accessor :key

    # the json hash for this AvlTraverseDto
    def to_jaxb_json_hash
      _h = {}
      _h['keyType'] = keyType.to_jaxb_json_hash unless keyType.nil?
      _h['key'] = key.to_jaxb_json_hash unless key.nil?
      return _h
    end

    # the json (string form) for this AvlTraverseDto
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this AvlTraverseDto with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['keyType'].nil?
          _oa = _o['keyType']
            if(_oa.is_a? Hash)
              @keyType = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @keyType =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @keyType = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @keyType.push String.from_json(_item)
                 else
                   @keyType.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @keyType = _oa
            end
          end
        if !_o['key'].nil?
          _oa = _o['key']
            if(_oa.is_a? Hash)
              @key = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @key =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @key = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @key.push String.from_json(_item)
                 else
                   @key.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @key = _oa
            end
          end
    end

    # constructs a AvlTraverseDto from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

module Io

module Privacyblockchain

module Rest

module Dto

  # (no documentation provided)
  class ChainIdDto 

    # (no documentation provided)
    attr_accessor :chainId

    # the json hash for this ChainIdDto
    def to_jaxb_json_hash
      _h = {}
      _h['chainId'] = chainId.to_jaxb_json_hash unless chainId.nil?
      return _h
    end

    # the json (string form) for this ChainIdDto
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this ChainIdDto with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['chainId'].nil?
          _oa = _o['chainId']
            if(_oa.is_a? Hash)
              @chainId = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @chainId =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @chainId = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @chainId.push String.from_json(_item)
                 else
                   @chainId.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @chainId = _oa
            end
          end
    end

    # constructs a ChainIdDto from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

module Io

module Privacyblockchain

module Rest

module Dto

module Traversing

  # (no documentation provided)
  class TraversePathDto 

    # (no documentation provided)
    attr_accessor :path

    # the json hash for this TraversePathDto
    def to_jaxb_json_hash
      _h = {}
      if !path.nil?
        _ha = Array.new
        path.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['path'] = _ha
      end
      return _h
    end

    # the json (string form) for this TraversePathDto
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this TraversePathDto with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['path'].nil?
          _oa = _o['path']
            if(_oa.is_a? Hash)
              @path = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @path =  Io::Privacyblockchain::Rest::Dto::Traversing::TraverseDto.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @path = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @path.push Io::Privacyblockchain::Rest::Dto::Traversing::TraverseDto.from_json(_item)
                 else
                   @path.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @path = _oa
            end
          end
    end

    # constructs a TraversePathDto from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

module Io

module Privacyblockchain

module Rest

module Dto

  # (no documentation provided)
  class BlockDto 

    # (no documentation provided)
    attr_accessor :state
    # (no documentation provided)
    attr_accessor :blockTime
    # (no documentation provided)
    attr_accessor :parentBlock
    # (no documentation provided)
    attr_accessor :transactions
    # (no documentation provided)
    attr_accessor :identifier
    # (no documentation provided)
    attr_accessor :productionTime

    # the json hash for this BlockDto
    def to_jaxb_json_hash
      _h = {}
      _h['state'] = state.to_jaxb_json_hash unless state.nil?
      _h['blockTime'] = blockTime.to_jaxb_json_hash unless blockTime.nil?
      _h['parentBlock'] = parentBlock.to_jaxb_json_hash unless parentBlock.nil?
      if !transactions.nil?
        _ha = Array.new
        transactions.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['transactions'] = _ha
      end
      _h['identifier'] = identifier.to_jaxb_json_hash unless identifier.nil?
      _h['productionTime'] = productionTime.to_jaxb_json_hash unless productionTime.nil?
      return _h
    end

    # the json (string form) for this BlockDto
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this BlockDto with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['state'].nil?
          _oa = _o['state']
            if(_oa.is_a? Hash)
              @state = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @state =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @state = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @state.push String.from_json(_item)
                 else
                   @state.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @state = _oa
            end
          end
        if !_o['blockTime'].nil?
          _oa = _o['blockTime']
            if(_oa.is_a? Hash)
              @blockTime = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @blockTime =  Bignum.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @blockTime = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @blockTime.push Bignum.from_json(_item)
                 else
                   @blockTime.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @blockTime = _oa
            end
          end
        if !_o['parentBlock'].nil?
          _oa = _o['parentBlock']
            if(_oa.is_a? Hash)
              @parentBlock = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @parentBlock =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @parentBlock = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @parentBlock.push String.from_json(_item)
                 else
                   @parentBlock.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @parentBlock = _oa
            end
          end
        if !_o['transactions'].nil?
          _oa = _o['transactions']
            if(_oa.is_a? Hash)
              @transactions = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @transactions =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @transactions = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @transactions.push String.from_json(_item)
                 else
                   @transactions.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @transactions = _oa
            end
          end
        if !_o['identifier'].nil?
          _oa = _o['identifier']
            if(_oa.is_a? Hash)
              @identifier = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @identifier =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @identifier = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @identifier.push String.from_json(_item)
                 else
                   @identifier.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @identifier = _oa
            end
          end
        if !_o['productionTime'].nil?
          _oa = _o['productionTime']
            if(_oa.is_a? Hash)
              @productionTime = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @productionTime =  Bignum.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @productionTime = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @productionTime.push Bignum.from_json(_item)
                 else
                   @productionTime.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @productionTime = _oa
            end
          end
    end

    # constructs a BlockDto from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

module Io

module Privacyblockchain

module Rest

module Dto

  # (no documentation provided)
  class ExecutedTransactionDto 

    # (no documentation provided)
    attr_accessor :from
    # (no documentation provided)
    attr_accessor :interactionJarHash
    # (no documentation provided)
    attr_accessor :finalized
    # (no documentation provided)
    attr_accessor :transactionPayload
    # (no documentation provided)
    attr_accessor :interactionContractType
    # (no documentation provided)
    attr_accessor :executionSucceeded
    # (no documentation provided)
    attr_accessor :events
    # (no documentation provided)
    attr_accessor :block
    # (no documentation provided)
    attr_accessor :identifier

    # the json hash for this ExecutedTransactionDto
    def to_jaxb_json_hash
      _h = {}
      _h['from'] = from.to_jaxb_json_hash unless from.nil?
      _h['interactionJarHash'] = interactionJarHash.to_jaxb_json_hash unless interactionJarHash.nil?
      _h['finalized'] = finalized.to_jaxb_json_hash unless finalized.nil?
      if !transactionPayload.nil?
        _ha = Array.new
        transactionPayload.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['transactionPayload'] = _ha
      end
      _h['interactionContractType'] = interactionContractType.to_jaxb_json_hash unless interactionContractType.nil?
      _h['executionSucceeded'] = executionSucceeded.to_jaxb_json_hash unless executionSucceeded.nil?
      if !events.nil?
        _ha = Array.new
        events.each { | _item | _ha.push _item.to_jaxb_json_hash }
        _h['events'] = _ha
      end
      _h['block'] = block.to_jaxb_json_hash unless block.nil?
      _h['identifier'] = identifier.to_jaxb_json_hash unless identifier.nil?
      return _h
    end

    # the json (string form) for this ExecutedTransactionDto
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this ExecutedTransactionDto with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['from'].nil?
          _oa = _o['from']
            if(_oa.is_a? Hash)
              @from = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @from =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @from = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @from.push String.from_json(_item)
                 else
                   @from.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @from = _oa
            end
          end
        if !_o['interactionJarHash'].nil?
          _oa = _o['interactionJarHash']
            if(_oa.is_a? Hash)
              @interactionJarHash = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @interactionJarHash =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @interactionJarHash = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @interactionJarHash.push String.from_json(_item)
                 else
                   @interactionJarHash.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @interactionJarHash = _oa
            end
          end
        if !_o['finalized'].nil?
          _oa = _o['finalized']
            if(_oa.is_a? Hash)
              @finalized = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @finalized =  Boolean.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @finalized = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @finalized.push Boolean.from_json(_item)
                 else
                   @finalized.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @finalized = _oa
            end
          end
        if !_o['transactionPayload'].nil?
          _oa = _o['transactionPayload']
            if(_oa.is_a? Hash)
              @transactionPayload = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @transactionPayload =  Fixnum.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @transactionPayload = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @transactionPayload.push Fixnum.from_json(_item)
                 else
                   @transactionPayload.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @transactionPayload = _oa
            end
          end
        if !_o['interactionContractType'].nil?
          _oa = _o['interactionContractType']
            if(_oa.is_a? Hash)
              @interactionContractType = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @interactionContractType =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @interactionContractType = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @interactionContractType.push String.from_json(_item)
                 else
                   @interactionContractType.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @interactionContractType = _oa
            end
          end
        if !_o['executionSucceeded'].nil?
          _oa = _o['executionSucceeded']
            if(_oa.is_a? Hash)
              @executionSucceeded = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @executionSucceeded =  Boolean.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @executionSucceeded = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @executionSucceeded.push Boolean.from_json(_item)
                 else
                   @executionSucceeded.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @executionSucceeded = _oa
            end
          end
        if !_o['events'].nil?
          _oa = _o['events']
            if(_oa.is_a? Hash)
              @events = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @events =  Io::Privacyblockchain::Rest::Dto::EventDto.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @events = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @events.push Io::Privacyblockchain::Rest::Dto::EventDto.from_json(_item)
                 else
                   @events.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @events = _oa
            end
          end
        if !_o['block'].nil?
          _oa = _o['block']
            if(_oa.is_a? Hash)
              @block = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @block =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @block = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @block.push String.from_json(_item)
                 else
                   @block.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @block = _oa
            end
          end
        if !_o['identifier'].nil?
          _oa = _o['identifier']
            if(_oa.is_a? Hash)
              @identifier = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @identifier =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @identifier = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @identifier.push String.from_json(_item)
                 else
                   @identifier.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @identifier = _oa
            end
          end
    end

    # constructs a ExecutedTransactionDto from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

module Io

module Privacyblockchain

module Rest

module Dto

  # (no documentation provided)
  class AccountStateDto 

    # (no documentation provided)
    attr_accessor :nonce

    # the json hash for this AccountStateDto
    def to_jaxb_json_hash
      _h = {}
      _h['nonce'] = nonce.to_jaxb_json_hash unless nonce.nil?
      return _h
    end

    # the json (string form) for this AccountStateDto
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this AccountStateDto with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['nonce'].nil?
          _oa = _o['nonce']
            if(_oa.is_a? Hash)
              @nonce = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @nonce =  Bignum.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @nonce = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @nonce.push Bignum.from_json(_item)
                 else
                   @nonce.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @nonce = _oa
            end
          end
    end

    # constructs a AccountStateDto from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

module Io

module Privacyblockchain

module Rest

module Dto

module Traversing

  # (no documentation provided)
  class FieldTraverseDto 

    # (no documentation provided)
    attr_accessor :name

    # the json hash for this FieldTraverseDto
    def to_jaxb_json_hash
      _h = {}
      _h['name'] = name.to_jaxb_json_hash unless name.nil?
      return _h
    end

    # the json (string form) for this FieldTraverseDto
    def to_json
      to_jaxb_json_hash.to_json
    end

    #initializes this FieldTraverseDto with a json hash
    def init_jaxb_json_hash(_o)
        if !_o['name'].nil?
          _oa = _o['name']
            if(_oa.is_a? Hash)
              @name = EnunciateHelpers::LAMB_CLASS_AWARE.call(_oa) if _oa['@class']
              @name =  String.from_json(_oa) unless _oa['@class']
            elsif (_oa.is_a? Array)
              #an array(of hashes hopefully) or scalar
              @name = Array.new
              _oa.each { | _item | 
                 if ((_item.nil? || _item['@class'].nil?)rescue true)
                   @name.push String.from_json(_item)
                 else
                   @name.push EnunciateHelpers::LAMB_CLASS_AWARE.call(_item)
                 end
               }
            else
                @name = _oa
            end
          end
    end

    # constructs a FieldTraverseDto from a (parsed) JSON hash
    def self.from_json(o)
      if o.nil?
        return nil
      else
        inst = new
        inst.init_jaxb_json_hash o
        return inst
      end
    end
  end

end

end

end

end

end

module Io

module Privacyblockchain

module Contract

module Sys

  # (no documentation provided)
  class ContractType

    # (no documentation provided)
    SYSTEM = "SYSTEM"

    # (no documentation provided)
    PUBLIC = "PUBLIC"

    # (no documentation provided)
    ZERO_KNOWLEDGE = "ZERO_KNOWLEDGE"
  end

end

end

end

end

module Io

module Privacyblockchain

module Rest

module Dto

module Traversing

  # (no documentation provided)
  class AvlKeyType

    # (no documentation provided)
    STRING = "STRING"

    # (no documentation provided)
    INTEGER = "INTEGER"

    # (no documentation provided)
    LONG = "LONG"

    # (no documentation provided)
    BLOCKCHAIN_ADDRESS = "BLOCKCHAIN_ADDRESS"
  end

end

end

end

end

end
